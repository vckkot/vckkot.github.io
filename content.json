{"meta":{"title":"SkyL Blog","subtitle":"IT 执着 追求","description":"人静而后安，安而能后定，定而能后慧，慧而能后悟，悟而能后得。","author":"vckkot","url":"https://vckkot.github.io"},"pages":[{"title":"categories","date":"2018-10-19T05:55:52.000Z","updated":"2021-07-04T13:41:25.317Z","comments":false,"path":"categories/index.html","permalink":"https://vckkot.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-10-19T05:56:19.000Z","updated":"2021-07-04T13:41:25.314Z","comments":false,"path":"about/index.html","permalink":"https://vckkot.github.io/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-10-19T05:55:58.000Z","updated":"2021-07-04T13:41:25.320Z","comments":false,"path":"tags/index.html","permalink":"https://vckkot.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-07-04T13:41:25.305Z","updated":"2021-07-04T13:41:25.305Z","comments":true,"path":"hello-world/","link":"","permalink":"https://vckkot.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"java.io.File 一些基础","slug":"java.io.File 一些基础","date":"2018-10-24T08:58:36.000Z","updated":"2021-07-04T13:41:25.307Z","comments":true,"path":"java.io.File 一些基础/","link":"","permalink":"https://vckkot.github.io/java.io.File 一些基础/","excerpt":"File java.io.FileFile表示操作系统中文件系统里的一个文件或目录使用File可以：1.访问一个文件或目录的属性信息2.操作一个文件或目录（创建，删除）3.访问一个目录的子项但是不能使用File访问文件数据","text":"File java.io.FileFile表示操作系统中文件系统里的一个文件或目录使用File可以：1.访问一个文件或目录的属性信息2.操作一个文件或目录（创建，删除）3.访问一个目录的子项但是不能使用File访问文件数据 Flie方法 在创建File的时候书写路径尽量使用相对路径，避免平台差异化，目录层级别分割符应当使用File里面的一个常量File.separator，常见的相对路径： 1.“.”：表示当前目录，当前目录运行环境不同路径也不同，在eclipse中运行java程序时的当前目录类所在项目的根目录 2.类的加载路径1234567891011121314151617public static void main(String[] args) &#123; File file = new File(\".\"+File.separator+\"test.txt\"); String name= file.getName(); System.out.println(name);//读取文件名字 long length = file.length(); System.out.println(length);//读取文件大小 boolean canRead = file.canRead();//是否可读 boolean canWrite = file.canWrite();//是否可写 System.out.println(\"可读:\"+canRead); System.out.println(\"可写:\"+canWrite); boolean isHidden = file.isHidden();//是否隐藏 System.out.println(\"是否为隐藏：\"+isHidden); &#125;&#125; boolean createNewFile() 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。 123public static void main(String[] args) throws IOException &#123; //在当前文件下创建一个demo.txt的文件File file = new File(\".\"+File.separator+\"demo1.txt\"); boolean exists() 判断File表示的文件或目录是否真实存在12345678if(!file.exists()) &#123; file.createNewFile();//报错补错 System.out.println(\"文件创建完毕！\"); &#125;else &#123; System.out.println(\"文件已经存在！\");&#125; &#125;&#125; 获取当前目录中的所有子项boolean isFile() 判断当前File表示的是否为一个文件 boolean isDirectory() 判断当前File表示的是否为一个目录 1234567891011121314151617public static void main(String[] args) &#123;File dir = new File(\".\");if(dir.isDirectory()) &#123; File[] subs = dir.listFiles(); System.out.println(subs.length);//有多少文件和目录 for(int i = 0 ; i&lt;subs.length; i++) &#123; File sub = subs[i]; if(sub.isDirectory()) &#123;//判断是否为目录 System.out.print(\"目录：\"); &#125; if(sub.isFile()) &#123;//判断是否为文件 System.out.print(\"文件：\"); &#125;System.out.println(sub.getName());//输出文件名 &#125; &#125; &#125;&#125; boolean accept(File pathname) 测试指定抽象路径名是否应该包含在某个路径名列表中。 File提供了一个重载的listFire方法 该方法允许我们传入一个文件过滤器FileFilter 该方法会将File表示的目录中所有满足过滤器要求的子项返回，而不满足的则被忽略。 12345678910111213141516171819public class File_listFiles2 &#123;public static void main(String[] args) &#123; //获取当前路径中所有名字以“.”开头的子项 File dir = new File(\".\");FileFilter FileFilter = new FileFilter() &#123; // boolean accept(File pathname) //测试指定抽象路径名是否应该包含在某个路径名列表中。 public boolean accept(File file) &#123; String name = file.getName();//获取不符合“.”开头的文件 System.out.println(\"正在过滤子项：\"+name); return name.startsWith(\".\"); &#125; &#125;; File[] subs = dir.listFiles(FileFilter); for(int i = 0; i&lt;subs.length; i++) &#123; System.out.println(subs[i].getName()); &#125; &#125;&#125; boolean mkdir() 创建一个目录 123456789101112public class File_mkdir &#123; public static void main(String[] args) &#123; //在当前目录中创建一个名为demo的目录 File dir = new File(\"demo\"); if(!dir.exists()) &#123; dir.mkdir(); System.out.println(\"该目录已创建！\"); &#125;else &#123; System.out.println(\"该目录已存在！\"); &#125; &#125; &#125; boolean mkdirs() 创建一个多级目录 123456789101112public static void main(String[] args) &#123;//在当前目录中创建 a/b/c/d/e/fFile dirs = new File(\"a\"+File.separator+\"b\"+File.separator+\"c\"+File.separator+\"d\"+File.separator+\"e\"+File.separator+\"f\");if(!dirs.exists()) &#123; //mkdirs是在创建当前File表示的目录同时将该目录其上的所有不存在的父目录一同创建出来 dirs.mkdirs(); System.out.println(\"文件目录创建完毕！\");&#125;else &#123; System.out.println(\"文件目录已存在！\"); &#125; &#125;&#125; boolean delete() 删除一个文件 将当前目录中的demo.txt删除相对路径默认是从“当前目录”开始所以，new File(&quot;demo.txt&quot;）等同new File(&quot;./demo.txt) 注：delete方法在删除目录的时候，需要注意，只能删除空目录； 删除一个文件： 12345678910public static void main(String[] args) &#123; File file = new File(\"demo.txt\"); if(file.exists()) &#123; file.delete(); System.out.println(\"文件已删除\"); &#125;else &#123; System.out.println(\"该文件不存在\"); &#125; &#125;&#125; 删除一个目录： 1234567891011public static void main(String[] args) &#123;File del = new File(\"demo\");//将当前目录中的demo目录删除if(del.exists()) &#123; // delete方法在删除目录的时候，需要注意，只能删除空目录； del.delete();//必须是空目录才能删 System.out.println(\"目录已删除！\");&#125;else &#123; System.out.println(\"该目录不存在！\"); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"版权测试","slug":"版权测试","date":"2018-10-24T06:25:54.000Z","updated":"2021-07-04T13:41:25.309Z","comments":true,"path":"版权测试/","link":"","permalink":"https://vckkot.github.io/版权测试/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"评论测试","slug":"评论测试","date":"2018-10-18T09:23:24.000Z","updated":"2021-07-04T13:41:25.311Z","comments":true,"path":"评论测试/","link":"","permalink":"https://vckkot.github.io/评论测试/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JDBC","slug":"JDBC","date":"2018-10-17T09:29:06.000Z","updated":"2021-07-04T13:41:25.303Z","comments":true,"path":"JDBC/","link":"","permalink":"https://vckkot.github.io/JDBC/","excerpt":"JDBC@(Java) ResultSetMetaData[toc] 1. MetaData–元数据 是指结果集对象的相关其他数据,比如说总列数,每一列的名称,每一列的sql数据类型,每一列的java数据类型等 案例演示 1234567891011121314151617181920212223242526272829303132333435363738 public static void main(String[] args) &#123; Connection conn=null; String sql=\"select id,name,password from dept where id&lt;?\"; try &#123; conn=DBUtiles.getConnection(); PreparedStatement ps=conn.prepareStatement(sql); ps.setInt(1, 100); ResultSet rs=ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData meta=rs.getMetaData(); //遍历并显示结果集中所有列的名称 for (int i = 1; i &lt;= meta.getColumnCount(); i++) &#123; System.out.println(meta.getColumnName(i)); &#125; //获得结果集的所有列数量// int n=meta.getColumnCount();// System.out.println(n); //通过下标获得结果集的某一列的列名// String name1=meta.getColumnName(1);// String name2=meta.getColumnName(2);// System.out.println(name1);// System.out.println(name2);// while (rs.next()) &#123;// System.out.println(rs.getString(\"name\"));// &#125; //关闭结果集 rs.close(); //关闭PS对象 ps.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBUtiles.closeConnection(conn); &#125; &#125;&#125;","text":"JDBC@(Java) ResultSetMetaData[toc] 1. MetaData–元数据 是指结果集对象的相关其他数据,比如说总列数,每一列的名称,每一列的sql数据类型,每一列的java数据类型等 案例演示 1234567891011121314151617181920212223242526272829303132333435363738 public static void main(String[] args) &#123; Connection conn=null; String sql=\"select id,name,password from dept where id&lt;?\"; try &#123; conn=DBUtiles.getConnection(); PreparedStatement ps=conn.prepareStatement(sql); ps.setInt(1, 100); ResultSet rs=ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData meta=rs.getMetaData(); //遍历并显示结果集中所有列的名称 for (int i = 1; i &lt;= meta.getColumnCount(); i++) &#123; System.out.println(meta.getColumnName(i)); &#125; //获得结果集的所有列数量// int n=meta.getColumnCount();// System.out.println(n); //通过下标获得结果集的某一列的列名// String name1=meta.getColumnName(1);// String name2=meta.getColumnName(2);// System.out.println(name1);// System.out.println(name2);// while (rs.next()) &#123;// System.out.println(rs.getString(\"name\"));// &#125; //关闭结果集 rs.close(); //关闭PS对象 ps.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBUtiles.closeConnection(conn); &#125; &#125;&#125; 2.由于jdbc自动提交事务,所以需要手动关闭 案例演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Demo2 &#123;/** * 由于JDBC自动事务提交 * 1.关闭自动提交conn.setAutoCommit(false); * 2.try的最后部分手动提交conn.commit(); * 3.由于一出现错误,就会运行catch块 * 在catch中conn.rollback(); * 4.封装回滚方法 * @param args */ static String sql1=\"update bal set\" + \" money=money+? where id=?\"; static String sql2=\"select money from bal where id=?\"; public static void main(String[] args) &#123; pay(2, 4, 1000); &#125; public static void pay(int from,int to,double money)&#123; Connection conn=null; try &#123; conn=DBUtiles.getConnection(); //关闭自动commit conn.setAutoCommit(false); PreparedStatement ps=conn.prepareStatement(sql1); /** * 业务模块---a--&gt;b 打1000 * create table bal( * id int, * name varchar(20), * money double(8,2) * ) */ //a-1000 ps.setDouble(1, -money); ps.setInt(2, from); int n=ps.executeUpdate(); //更新失败 if (n!=1) &#123; throw new Exception(\"减钱失败\"); &#125; //b+1000 ps.setDouble(1, money); ps.setInt(2, to); n=ps.executeUpdate(); if (n!=1) &#123; throw new Exception(\"加钱失败\"); &#125; ps.close(); //检查a有没有1000 ps=conn.prepareStatement(sql2); ps.setInt(1, from); ResultSet rs=ps.executeQuery(); while (rs.next()) &#123; double bal=rs.getDouble(1); if (bal&lt;0) &#123; throw new Exception(\"余额不足\"); &#125; &#125; //手动提交 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); DBUtiles.rollback(conn); &#125;finally &#123; DBUtiles.closeConnection(conn); &#125; &#125;&#125; 批量更新 把多条sql存入Statement对象的缓存,一次性发送给DB执行 1234Statement sta=conn.createStatement();// sta.addBatch(sql1);// sta.addBatch(sql2); // int[] arr=sta.executeBatch(); 创建一个执行计划,把多条参数存入PreParedStatement对象缓存中,一次性发送给DB执行 12345PreparedStatement ps=conn.prepareStatement(sql6); ps.setInt(1, 1);ps.setString(2, \"lili\");ps.addBatch(); int[] arr=ps.executeBatch(); 内存溢出OutOfMemory 获取自动生成的主键 String[] colNames={&quot;id&quot;}; 自动生成值的列的列名 PreparedStatement ps =conn.prepareStatement(sql1, colNames);必须与上面的命令一起使用 ps.getGeneratedKeys() 案例演示 public static void main(String[] args) { String sql1=&quot;create table &quot; + &quot;log1 (id int ,msg varchar(20))&quot;; String sql2=&quot;create table &quot; + &quot;log2 (id int ,msg varchar(20))&quot;; String sql3=&quot;create table &quot; + &quot;log3 (id int ,msg varchar(20))&quot;; String sql4=&quot;create table &quot; + &quot;log4 (id int ,msg varchar(20))&quot;; String sql5=&quot;create table &quot; + &quot;log5 (id int ,msg varchar(20))&quot;; String sql6=&quot;insert into log1 values &quot; + &quot;(?,?)&quot;; String sql7=&quot;insert into log2 values &quot; + &quot;(?,?)&quot;; //获得连接对象 Connection conn=null; try { conn=DBUtiles.getConnection(); //批量更新的第一种方法 //把多个sql语句存入sta对象的缓存中 // Statement sta=conn.createStatement(); // sta.addBatch(sql1); // sta.addBatch(sql2); // sta.addBatch(sql3); // sta.addBatch(sql4); // sta.addBatch(sql5); //一次性发送给数据库执行 //返回值 &gt;=0---成功,有结果 //返回值-2----成功,没有结果 //返回值-3----不成功 // int[] arr=sta.executeBatch(); // System.out.println(Arrays.toString(arr)); //第二中批量更新的方式 //使用ps固定一个执行计划 //把一堆参数存入ps的缓存 //一次性发送给DB,进行处理 // PreparedStatement ps=conn.prepareStatement(sql6); // // ps.setInt(1, 1); // ps.setString(2, &quot;lili&quot;); // ps.addBatch(); // // ps.setInt(1, 2); // ps.setString(2, &quot;lucy&quot;); // ps.addBatch(); // // int[] arr=ps.executeBatch(); // System.out.println(Arrays.toString(arr)); PreparedStatement ps =conn.prepareStatement(sql7); for (int i = 1; i &lt; 100; i++) { ps.setInt(1, i); ps.setString(2, &quot;test&quot;+i); ps.addBatch(); if (i%8==0) {//97.98.99 ps.executeBatch(); } } ps.executeBatch(); } catch (Exception e) { e.printStackTrace(); }finally { DBUtiles.closeConnection(conn); } } DAO DAO作为数据访问层,把业务逻辑层和数据库分割开来 业务逻辑层需要数据,就跟DAO要 业务逻辑层要保存数据,就交给DAO,让DAO去保存 业务逻辑层不关系数据如何获取,如何保存,全部都由DAO负责 案例演示 public class UserDAO1 implements UserDAO{ private static final String search_by_id =&quot;select * from user_1 where id=?&quot;; private static final String search_all =&quot;select * from user_1&quot;; private static final String update_user_password =&quot;update user_1 set name=?,password=? where id=?&quot;; private static final String insert_user =&quot;insert into user_1 values(null,?,?,?)&quot;; public User findUserById(int id) { Connection conn=null; try { conn=DBUtiles.getConnection(); PreparedStatement ps=conn.prepareStatement(search_by_id); ps.setInt(1, id); ResultSet rs=ps.executeQuery(); int i=0; String name=null; String pwd=null; int age=0; while(rs.next()){ i=rs.getInt(1); name=rs.getString(2); pwd=rs.getString(3); age=rs.getInt(4); } return new User(i, name, pwd, age); } catch (Exception e) { e.printStackTrace(); DBUtiles.rollback(conn); }finally{ DBUtiles.closeConnection(conn); } return null; } public List&lt;User&gt; findAllUser() { Connection conn=null; try { conn=DBUtiles.getConnection(); conn.setAutoCommit(false); Statement sta=conn.createStatement(); ResultSet rs=sta.executeQuery(search_all); List&lt;User&gt; list=new ArrayList&lt;User&gt;(); while (rs.next()) { int i=rs.getInt(1); String name=rs.getString(2); String pwd=rs.getString(3); int age=rs.getInt(4); User user=new User(i, name, pwd, age); list.add(user); } conn.commit(); return list; } catch (Exception e) { e.printStackTrace(); DBUtiles.rollback(conn); }finally { DBUtiles.closeConnection(conn); } return null; } public int updateUser(User user) { Connection conn=null; try { conn=DBUtiles.getConnection(); PreparedStatement ps=conn.prepareStatement(update_user_password); ps.setString(1, user.getName()); ps.setString(2, user.getPwd()); ps.setInt(3, user.getId()); int n=ps.executeUpdate(); if (n!=1) { throw new Exception(&quot;修改失败&quot;); } ps.close(); } catch (Exception e) { e.printStackTrace(); DBUtiles.rollback(conn); }finally { DBUtiles.closeConnection(conn); } return 0; } public int saveUser(User user) { Connection conn=null; try { conn=DBUtiles.getConnection(); PreparedStatement ps=conn.prepareStatement(insert_user); ps.setString(1, user.getName()); ps.setString(2, user.getPwd()); ps.setInt(3, user.getAge()); int n=ps.executeUpdate(); if (n!=1) { throw new Exception(&quot;插入失败&quot;); } ps.close(); } catch (Exception e) { e.printStackTrace(); DBUtiles.rollback(conn); }finally { DBUtiles.closeConnection(conn); } return 0; } } 测试类 public static void main(String[] args) { //数据---&gt;数据库读取出来的 //验证dao的findUserById方法 UserDAO dao=new UserDAO1(); //验证dao的findall //List&lt;User&gt; list=dao.findAllUser(); //for (int i = 0; i &lt; list.size(); i++) { //System.out.println(list.get(i).getId()); //} //验证dao的修改方法 //User user=new User(2, &quot;xiongda&quot;, &quot;321&quot;, 18); //dao.updateUser(user); //验证dao的插入方法 User user=new User(1232, &quot;xiongda&quot;, &quot;321&quot;, 18); dao.saveUser(user); }","categories":[{"name":"Java","slug":"Java","permalink":"https://vckkot.github.io/categories/Java/"},{"name":"MySQL","slug":"Java/MySQL","permalink":"https://vckkot.github.io/categories/Java/MySQL/"}],"tags":[]}]}