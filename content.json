{"meta":{"title":"SkyL的博客","subtitle":"IT 执着 追求","description":"人静而后安，安而能后定，定而能后慧，慧而能后悟，悟而能后得。","author":"vckkot","url":"https://vckkot.github.io"},"pages":[],"posts":[{"title":"评论测试","slug":"评论测试","date":"2018-10-18T09:23:24.000Z","updated":"2018-10-18T09:30:23.658Z","comments":true,"path":"2018/10/18/评论测试/","link":"","permalink":"https://vckkot.github.io/2018/10/18/评论测试/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JDBC","slug":"JDBC","date":"2018-10-17T09:29:06.000Z","updated":"2018-10-17T09:29:50.536Z","comments":true,"path":"2018/10/17/JDBC/","link":"","permalink":"https://vckkot.github.io/2018/10/17/JDBC/","excerpt":"","text":"#JDBC @(Java) ##ResultSetMetaData[toc] ###1. MetaData–元数据 是指结果集对象的相关其他数据,比如说总列数,每一列的名称,每一列的sql数据类型,每一列的java数据类型等 案例演示 1234567891011121314151617181920212223242526272829303132333435363738 public static void main(String[] args) &#123; Connection conn=null; String sql=&quot;select id,name,password from dept where id&lt;?&quot;; try &#123; conn=DBUtiles.getConnection(); PreparedStatement ps=conn.prepareStatement(sql); ps.setInt(1, 100); ResultSet rs=ps.executeQuery(); //获取结果集的元数据 ResultSetMetaData meta=rs.getMetaData(); //遍历并显示结果集中所有列的名称 for (int i = 1; i &lt;= meta.getColumnCount(); i++) &#123; System.out.println(meta.getColumnName(i)); &#125; //获得结果集的所有列数量// int n=meta.getColumnCount();// System.out.println(n); //通过下标获得结果集的某一列的列名// String name1=meta.getColumnName(1);// String name2=meta.getColumnName(2);// System.out.println(name1);// System.out.println(name2);// while (rs.next()) &#123;// System.out.println(rs.getString(&quot;name&quot;));// &#125; //关闭结果集 rs.close(); //关闭PS对象 ps.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBUtiles.closeConnection(conn); &#125; &#125;&#125; ###2.由于jdbc自动提交事务,所以需要手动关闭 案例演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Demo2 &#123;/** * 由于JDBC自动事务提交 * 1.关闭自动提交conn.setAutoCommit(false); * 2.try的最后部分手动提交conn.commit(); * 3.由于一出现错误,就会运行catch块 * 在catch中conn.rollback(); * 4.封装回滚方法 * @param args */ static String sql1=&quot;update bal set&quot; + &quot; money=money+? where id=?&quot;; static String sql2=&quot;select money from bal where id=?&quot;; public static void main(String[] args) &#123; pay(2, 4, 1000); &#125; public static void pay(int from,int to,double money)&#123; Connection conn=null; try &#123; conn=DBUtiles.getConnection(); //关闭自动commit conn.setAutoCommit(false); PreparedStatement ps=conn.prepareStatement(sql1); /** * 业务模块---a--&gt;b 打1000 * create table bal( * id int, * name varchar(20), * money double(8,2) * ) */ //a-1000 ps.setDouble(1, -money); ps.setInt(2, from); int n=ps.executeUpdate(); //更新失败 if (n!=1) &#123; throw new Exception(&quot;减钱失败&quot;); &#125; //b+1000 ps.setDouble(1, money); ps.setInt(2, to); n=ps.executeUpdate(); if (n!=1) &#123; throw new Exception(&quot;加钱失败&quot;); &#125; ps.close(); //检查a有没有1000 ps=conn.prepareStatement(sql2); ps.setInt(1, from); ResultSet rs=ps.executeQuery(); while (rs.next()) &#123; double bal=rs.getDouble(1); if (bal&lt;0) &#123; throw new Exception(&quot;余额不足&quot;); &#125; &#125; //手动提交 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); DBUtiles.rollback(conn); &#125;finally &#123; DBUtiles.closeConnection(conn); &#125; &#125;&#125; ###批量更新 把多条sql存入Statement对象的缓存,一次性发送给DB执行 1234Statement sta=conn.createStatement();// sta.addBatch(sql1);// sta.addBatch(sql2); // int[] arr=sta.executeBatch(); 创建一个执行计划,把多条参数存入PreParedStatement对象缓存中,一次性发送给DB执行 12345PreparedStatement ps=conn.prepareStatement(sql6); ps.setInt(1, 1);ps.setString(2, &quot;lili&quot;);ps.addBatch(); int[] arr=ps.executeBatch(); 内存溢出OutOfMemory ###获取自动生成的主键 String[] colNames={&quot;id&quot;}; 自动生成值的列的列名 PreparedStatement ps =conn.prepareStatement(sql1, colNames);必须与上面的命令一起使用 ps.getGeneratedKeys() 案例演示 public static void main(String[] args) { String sql1=&quot;create table &quot; + &quot;log1 (id int ,msg varchar(20))&quot;; String sql2=&quot;create table &quot; + &quot;log2 (id int ,msg varchar(20))&quot;; String sql3=&quot;create table &quot; + &quot;log3 (id int ,msg varchar(20))&quot;; String sql4=&quot;create table &quot; + &quot;log4 (id int ,msg varchar(20))&quot;; String sql5=&quot;create table &quot; + &quot;log5 (id int ,msg varchar(20))&quot;; String sql6=&quot;insert into log1 values &quot; + &quot;(?,?)&quot;; String sql7=&quot;insert into log2 values &quot; + &quot;(?,?)&quot;; //获得连接对象 Connection conn=null; try { conn=DBUtiles.getConnection(); //批量更新的第一种方法 //把多个sql语句存入sta对象的缓存中 // Statement sta=conn.createStatement(); // sta.addBatch(sql1); // sta.addBatch(sql2); // sta.addBatch(sql3); // sta.addBatch(sql4); // sta.addBatch(sql5); //一次性发送给数据库执行 //返回值 &gt;=0---成功,有结果 //返回值-2----成功,没有结果 //返回值-3----不成功 // int[] arr=sta.executeBatch(); // System.out.println(Arrays.toString(arr)); //第二中批量更新的方式 //使用ps固定一个执行计划 //把一堆参数存入ps的缓存 //一次性发送给DB,进行处理 // PreparedStatement ps=conn.prepareStatement(sql6); // // ps.setInt(1, 1); // ps.setString(2, &quot;lili&quot;); // ps.addBatch(); // // ps.setInt(1, 2); // ps.setString(2, &quot;lucy&quot;); // ps.addBatch(); // // int[] arr=ps.executeBatch(); // System.out.println(Arrays.toString(arr)); PreparedStatement ps =conn.prepareStatement(sql7); for (int i = 1; i &lt; 100; i++) { ps.setInt(1, i); ps.setString(2, &quot;test&quot;+i); ps.addBatch(); if (i%8==0) {//97.98.99 ps.executeBatch(); } } ps.executeBatch(); } catch (Exception e) { e.printStackTrace(); }finally { DBUtiles.closeConnection(conn); } } ##DAO DAO作为数据访问层,把业务逻辑层和数据库分割开来 业务逻辑层需要数据,就跟DAO要 业务逻辑层要保存数据,就交给DAO,让DAO去保存 业务逻辑层不关系数据如何获取,如何保存,全部都由DAO负责 案例演示 public class UserDAO1 implements UserDAO{ private static final String search_by_id =&quot;select * from user_1 where id=?&quot;; private static final String search_all =&quot;select * from user_1&quot;; private static final String update_user_password =&quot;update user_1 set name=?,password=? where id=?&quot;; private static final String insert_user =&quot;insert into user_1 values(null,?,?,?)&quot;; public User findUserById(int id) { Connection conn=null; try { conn=DBUtiles.getConnection(); PreparedStatement ps=conn.prepareStatement(search_by_id); ps.setInt(1, id); ResultSet rs=ps.executeQuery(); int i=0; String name=null; String pwd=null; int age=0; while(rs.next()){ i=rs.getInt(1); name=rs.getString(2); pwd=rs.getString(3); age=rs.getInt(4); } return new User(i, name, pwd, age); } catch (Exception e) { e.printStackTrace(); DBUtiles.rollback(conn); }finally{ DBUtiles.closeConnection(conn); } return null; } public List&lt;User&gt; findAllUser() { Connection conn=null; try { conn=DBUtiles.getConnection(); conn.setAutoCommit(false); Statement sta=conn.createStatement(); ResultSet rs=sta.executeQuery(search_all); List&lt;User&gt; list=new ArrayList&lt;User&gt;(); while (rs.next()) { int i=rs.getInt(1); String name=rs.getString(2); String pwd=rs.getString(3); int age=rs.getInt(4); User user=new User(i, name, pwd, age); list.add(user); } conn.commit(); return list; } catch (Exception e) { e.printStackTrace(); DBUtiles.rollback(conn); }finally { DBUtiles.closeConnection(conn); } return null; } public int updateUser(User user) { Connection conn=null; try { conn=DBUtiles.getConnection(); PreparedStatement ps=conn.prepareStatement(update_user_password); ps.setString(1, user.getName()); ps.setString(2, user.getPwd()); ps.setInt(3, user.getId()); int n=ps.executeUpdate(); if (n!=1) { throw new Exception(&quot;修改失败&quot;); } ps.close(); } catch (Exception e) { e.printStackTrace(); DBUtiles.rollback(conn); }finally { DBUtiles.closeConnection(conn); } return 0; } public int saveUser(User user) { Connection conn=null; try { conn=DBUtiles.getConnection(); PreparedStatement ps=conn.prepareStatement(insert_user); ps.setString(1, user.getName()); ps.setString(2, user.getPwd()); ps.setInt(3, user.getAge()); int n=ps.executeUpdate(); if (n!=1) { throw new Exception(&quot;插入失败&quot;); } ps.close(); } catch (Exception e) { e.printStackTrace(); DBUtiles.rollback(conn); }finally { DBUtiles.closeConnection(conn); } return 0; } } 测试类 public static void main(String[] args) { //数据---&gt;数据库读取出来的 //验证dao的findUserById方法 UserDAO dao=new UserDAO1(); //验证dao的findall //List&lt;User&gt; list=dao.findAllUser(); //for (int i = 0; i &lt; list.size(); i++) { //System.out.println(list.get(i).getId()); //} //验证dao的修改方法 //User user=new User(2, &quot;xiongda&quot;, &quot;321&quot;, 18); //dao.updateUser(user); //验证dao的插入方法 User user=new User(1232, &quot;xiongda&quot;, &quot;321&quot;, 18); dao.saveUser(user); }","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-10-17T07:42:23.055Z","updated":"2018-10-17T07:42:23.055Z","comments":true,"path":"2018/10/17/hello-world/","link":"","permalink":"https://vckkot.github.io/2018/10/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}